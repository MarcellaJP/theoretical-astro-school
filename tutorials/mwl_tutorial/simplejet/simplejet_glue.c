#define HAVE_LONG_LONG 1
/* * This file was generated by SLIRP, the (Sl)ang (I)nte(r)face (P)ackage,
 * a S-Lang module code generator for C, C++, and FORTRAN.
 *
 * Copyright (C) 2003-2009 Massachusetts Institute of Technology 
 * Copyright (C) 2002 Michael S. Noble <mnoble@space.mit.edu>
 *
 * SLIRP is free software, and may be used under the conditions stipulated
 * in the COPYRIGHT agreement bundled within the SLIRP distribution.
 */
#include <stdlib.h>		/* SLIRP common {{{ */
#include <unistd.h>
#include <string.h>
#include <stdarg.h>
#include <ctype.h>
#include <slang.h>

#define SAFE_DEREF_OPAQUE(po)		(po == NULL ? NULL : po->instance)
#define SAFE_DEREF_ARRAY(pa)		(pa == NULL ? NULL : pa->data)
#define SLang_pop_array(x)		SLang_pop_array(x, 1)
#define SLang_pop_string(x)             ( (SLang_peek_at_stack() == SLANG_NULL_TYPE && (SLdo_pop() || 1)) ? ((*x = NULL) || 1): SLang_pop_slstring(x))
#define SLang_push_size_t		SLang_push_ulong
#define SLang_push_ptrdiff_t		SLang_push_long

#define pop_defaultable(argno, kind, type, obj, value) \
   (SLang_Num_Function_Args >= argno ? SLang_pop_##kind ( (type*)&obj) : ((obj = value) || ( (void*)&obj > (void*)0) ) )

#ifdef __cplusplus
#define LINKAGE "C"
#else
#define LINKAGE
#endif

#define USAGE(msg) \
    {SLang_verror(SL_USAGE_ERROR, (char*)"Usage: %s", msg); return;}

static void Slirp_usage(int i, int j, int flags);

static int slang_abi_mismatch(void)
{
   long module_abi = SLANG_VERSION / 10000;
   long app_abi    = SLang_Version / 10000;

   if (module_abi != app_abi) {
	SLang_verror(SL_APPLICATION_ERROR, (char*)
		"S-Lang library abi mismatch\nmodule: %s, application: %s",
		SLANG_VERSION_STRING, SLang_Version_String);
	return 1;
   }
			        
   return 0;
} /* }}} */

static char *slns;  /* slang namespace active at time of module load */
/* General Fortran support */ /* {{{ */
typedef struct { float r, i; } spcomplex;	/* names chosen to minimize */
typedef struct { double r, i; } dpcomplex;	/* conflict w/ C99 complex  */
#define FTN_STR char*
#define FTN_STR_ARR char*
#define HAVE_FORTRAN_CODE 1
#define NDIMS(dims_array)  sizeof((dims_array)) / sizeof(SLindex_Type)
#define SLang_push_scomplex(c)		SLang_push_complex(c.r, c.i)
#define SLang_push_dcomplex(c)		SLang_push_complex(c.r, c.i)
#define SLang_pop_dcomplex(dc)	SLang_pop_complex((double*)dc,((double*)dc)+1)
#define TRANSPOSE(i,ARRAY)	(ARRAY)->num_dims > 1 ? transpose(i,(ARRAY)) : 0

static int SLang_pop_scomplex (spcomplex *c) /* {{{ */
{
   double dc[2];
   if (SLang_pop_complex(dc, dc+1) == -1)
	return -1;
   c->r = (float) dc[0]; /* information may be lost to truncation */
   c->i = (float) dc[1];
   return 0;
} /* }}} */

static SLang_Name_Type *transposer;

static int transpose(int to_row_major, SLang_Array_Type *a)  /* {{{ */
{
   void *tmpdata;
   SLang_Array_Type *transposed;
   static SLindex_Type dims[SLARRAY_MAX_DIMS];

   if (to_row_major) {
	unsigned int i = a->num_dims, j = 0;
	memcpy(dims, a->dims, a->num_dims * sizeof(SLindex_Type));
	while (i--)
	   a->dims[i] = dims[j++];
   }

   if (SLang_push_array(a, 0) == -1 || SLexecute_function(transposer) == -1
	 			    || SLang_pop_array(&transposed)   == -1)
	return -1;

   tmpdata = a->data;
   a->data = transposed->data;
   transposed->data = tmpdata;
   SLang_free_array(transposed);

   if (to_row_major)
	memcpy(a->dims, dims, a->num_dims * sizeof(SLindex_Type));

   return 0;
} /* }}} */

static int pop_space_padded_string (char **sp, size_t min_len)
{
   char *s;
   char *b;
   size_t len;

   *sp = NULL;
   if (-1 == SLang_pop_slstring (&s))
     return -1;

   if (NULL == (b = (char *)SLmalloc (min_len+1)))
     {
        SLang_free_slstring (s);
        return -1;
     }
   len = strlen (s);
   if (len > min_len) len = min_len;
   memcpy (b, s, len);
   memset (b+len, ' ', min_len-len);
   b[min_len] = 0;

   SLang_free_slstring (s);
   *sp = b;
   return 0;
}

static void free_space_padded_string (char *s)
{
   SLfree (s);                         /* NULL ok */
}

static int pack2for(SLang_Array_Type *slstrs, char** Packed, /* {{{ */
							size_t *Widest)
{
   /* Pack a S-Lang array of slstrings into a sequence */
   /* of space-padded, fixed-length Fortran strings    */
   char *packed, *p, **strings;
   size_t i, *widths, n, width = 0;

   if (slstrs->data_type != SLANG_STRING_TYPE) {
	SLang_verror(SL_USAGE_ERROR,(char*)"String array is required here");
	return -1;
   }

   strings = (char**)slstrs->data;
   n = slstrs->num_elements;

   if ( (widths = (size_t*)SLmalloc( n * sizeof(size_t) )) == NULL)
	return -1;

   for (i=0; i < n; i++) {
	widths[i] = strlen(strings[i]);
	if (widths[i] > width)
	   width = widths[i];
   }

   if ( (packed = SLmalloc( n * width )) == NULL) {
	SLfree((char*)widths);
	return -1;
   }
   memset(packed, ' ', n*width);

   p = packed;
   for (i=0; i<n; i++) {
	strncpy(p, strings[i], widths[i]);
	p += width;
   }

   *Packed = packed;
   *Widest = width;
   SLfree((char*)widths);
   return 0;
} /*}}}*/

static int unpack2c(char *p, SLang_Array_Type *slstrs, size_t width) /*{{{*/
{
   /* Unpack a sequence p of space-padded, fixed-length */
   /* Fortran strings into a SLang array of slstrings   */
   size_t i, n = slstrs->num_elements;
   char *str, **unpacked = (char**)slstrs->data;
   unsigned char free_elements = (slstrs->client_data == NULL);

   if ( (str = SLmalloc(width+1)) == NULL)
	return -1;

   for (i=0; i < n; i++, p += width) {
	memcpy(str, p, width);
	str[width] = 0;
	if (free_elements)
	   SLang_free_slstring(unpacked[i]);
	unpacked[i] = SLang_create_slstring(str);
   }

   SLfree(str);
   return 0;
} /*}}}*/


/* }}} */

#define BEGIN_DECLS
#define END_DECLS
/*  Fortran Common Blocks Support */  /* {{{ */

typedef struct _CommBlockVar CommBlockVar;

struct _CommBlockVar {
   char *name;
   SLtype sltype;
   void *data;
   int rank;
   SLindex_Type dims[SLARRAY_MAX_DIMS];
   int (*push) (CommBlockVar *);
   int (*pop) (CommBlockVar *);
} ;

typedef void (*CommBlock_Initializer) (void (*) (int*, int*, ...));
typedef struct {
   char *name;
   int num_vars;
   CommBlockVar *vars;
   CommBlock_Initializer init_func;
} CommBlock;

static int push_generic(CommBlockVar *v);
static int pop_generic(CommBlockVar *v);
static int push_fstring(CommBlockVar *v);
static int pop_fstring(CommBlockVar *v);
static int push_scomplex(CommBlockVar *v);
static int pop_scomplex(CommBlockVar *v);

static CommBlockVar derivs_com [] = {
  {(char*)"elen",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"drtrm",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yderb",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yderc",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yderd",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapderivs_( void (*) (int*, int*, ...));

static CommBlockVar eldis2_com [] = {
  {(char*)"elenmn",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"elenmx",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"bfield",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"dist",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapeldis2_( void (*) (int*, int*, ...));

static CommBlockVar com_com [] = {
  {(char*)"ephot",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {(char*)"phodis",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {(char*)"yphot",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapcom_( void (*) (int*, int*, ...));

static CommBlockVar spass_com [] = {
  {(char*)"nupass",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapspass_( void (*) (int*, int*, ...));

static CommBlockVar cpass_com [] = {
  {(char*)"gpass",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"e1",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapcpass_( void (*) (int*, int*, ...));

static CommBlockVar bbpars_com [] = {
  {(char*)"rin",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"rout",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"hbb",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"tin",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"zpass",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapbbpars_( void (*) (int*, int*, ...));

static CommBlockVar erdpar_com [] = {
  {(char*)"frq",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"inclin",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwraperdpar_( void (*) (int*, int*, ...));

static CommBlockVar jpars_com [] = {
  {(char*)"visco",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"mbh",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"zmin",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapjpars_( void (*) (int*, int*, ...));

static CommBlockVar com2_com [] = {
  {(char*)"ephpass",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"ephmax",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"ephmin",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapcom2_( void (*) (int*, int*, ...));

static CommBlockVar comsplinpar_com [] = {
  {(char*)"cb",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {(char*)"cc",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {(char*)"cd",SLANG_DOUBLE_TYPE,NULL,1,{100},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapcomsplinpar_( void (*) (int*, int*, ...));

static CommBlockVar cbgb_com [] = {
  {(char*)"gbx",SLANG_DOUBLE_TYPE,NULL,1,{120},push_generic,pop_generic},
  {(char*)"gby",SLANG_DOUBLE_TYPE,NULL,1,{120},push_generic,pop_generic},
  {(char*)"gbyb",SLANG_DOUBLE_TYPE,NULL,1,{120},push_generic,pop_generic},
  {(char*)"gbyc",SLANG_DOUBLE_TYPE,NULL,1,{120},push_generic,pop_generic},
  {(char*)"gbyd",SLANG_DOUBLE_TYPE,NULL,1,{120},push_generic,pop_generic},
  {(char*)"gbs0",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {(char*)"nv",SLANG_INT_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapcbgb_( void (*) (int*, int*, ...));

static CommBlockVar eldis1_com [] = {
  {(char*)"lelec",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"ledens",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yelb",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yelc",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {(char*)"yeld",SLANG_DOUBLE_TYPE,NULL,1,{200},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapeldis1_( void (*) (int*, int*, ...));

static CommBlockVar jetg_com [] = {
  {(char*)"gamv",SLANG_DOUBLE_TYPE,NULL,0,{0},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapjetg_( void (*) (int*, int*, ...));

static CommBlockVar syn_com [] = {
  {(char*)"arg",SLANG_DOUBLE_TYPE,NULL,1,{47},push_generic,pop_generic},
  {(char*)"val",SLANG_DOUBLE_TYPE,NULL,1,{47},push_generic,pop_generic},
  {(char*)"synb",SLANG_DOUBLE_TYPE,NULL,1,{47},push_generic,pop_generic},
  {(char*)"sync",SLANG_DOUBLE_TYPE,NULL,1,{47},push_generic,pop_generic},
  {(char*)"synd",SLANG_DOUBLE_TYPE,NULL,1,{47},push_generic,pop_generic},
  {NULL, 0, NULL, 0, {0}, NULL, NULL}
};
extern LINKAGE void sfwrapsyn_( void (*) (int*, int*, ...));
static CommBlock CommBlocks[] = {
  { (char*)"derivs", 5, derivs_com, sfwrapderivs_ },
  { (char*)"eldis2", 4, eldis2_com, sfwrapeldis2_ },
  { (char*)"com", 3, com_com, sfwrapcom_ },
  { (char*)"spass", 1, spass_com, sfwrapspass_ },
  { (char*)"cpass", 2, cpass_com, sfwrapcpass_ },
  { (char*)"bbpars", 5, bbpars_com, sfwrapbbpars_ },
  { (char*)"erdpar", 2, erdpar_com, sfwraperdpar_ },
  { (char*)"jpars", 3, jpars_com, sfwrapjpars_ },
  { (char*)"com2", 3, com2_com, sfwrapcom2_ },
  { (char*)"comsplinpar", 3, comsplinpar_com, sfwrapcomsplinpar_ },
  { (char*)"cbgb", 7, cbgb_com, sfwrapcbgb_ },
  { (char*)"eldis1", 5, eldis1_com, sfwrapeldis1_ },
  { (char*)"jetg", 1, jetg_com, sfwrapjetg_ },
  { (char*)"syn", 5, syn_com, sfwrapsyn_ },
  {NULL, 0, NULL, NULL }
};
static unsigned int Num_CommBlocks = 14;

static SLtype CommBlock_Type;

static void array_destroy_no_op(SLang_Array_Type *at)	/* {{{ */
{
  (void) at;
} /*}}}*/

static void block_destroy_no_op(SLtype t, void* p)	/* {{{ */
{
  (void) t;  (void) p;
} /*}}}*/

static void* findcomm(char* name, void *list, size_t next) /*{{{*/
{
   CommBlock *item = (CommBlock*) list;

   while (item->name != NULL && strcmp(item->name, name))
	 item = (CommBlock*) (((char*)item) + next);

   return ( item->name == NULL ? NULL : item);
} /*}}}*/

static int pop_common_block(CommBlock **block) /*{{{*/
{
    if ( SLang_peek_at_stack() == SLANG_STRING_TYPE) {

	char *blname = NULL;

	if (SLang_pop_slstring(&blname) == 0) {

	   *block = (CommBlock *)findcomm(blname, CommBlocks, sizeof(CommBlock));
	   SLang_free_slstring(blname);

	   if (*block == NULL)
		SLang_verror(SL_USAGE_ERROR,
			"No common blocks found with name: %s", blname);
	}
    }
    else  {

	SLang_MMT_Type *mmt;

	if (NULL != (mmt = SLang_pop_mmt(CommBlock_Type))) {
	    *block = (CommBlock *)SLang_object_from_mmt(mmt);
	    /* Since block destroy is a no-op, we can free the mmt here */
	    SLang_free_mmt(mmt);
	}
    }

    return SLang_get_error();
} /*}}}*/

static int push_fstring(CommBlockVar *v)  /* {{{ */
{  
   SLang_Array_Type *a;

   if (v->rank == 1)
	return SLang_push_malloced_string( SLmake_nstring((char *)v->data, v->dims[0]));

   /* Read-only b/c mapping back to CHARACTER doesn't happen on elem assign */
   if (NULL == (a = SLang_create_array(v->sltype,1,NULL, v->dims+1, v->rank-1)))
	return -1;

   a->client_data = v->data;
   unpack2c((char*)v->data, a, v->dims[0]);
   return SLang_push_array(a, 1);
}  /* }}} */

static int pop_fstring(CommBlockVar *v)  /* {{{ */
{
   char *s;

   if (SLang_pop_slstring(&s) != 0)
	return -1;

   strncpy((char *)v->data, s, v->dims[0]);
   SLang_free_slstring(s);

   return 0;
}  /* }}} */

static int push_scomplex(CommBlockVar *v) /*{{{*/
{
   /* Map Fortran single-prec complex to S-Lang's double-prec (only) complex */
   float *fc = (float *)v->data;

   if (v->rank == 0) {			/* Single value */
	double dc[2];
	dc[0] = fc[0];
	dc[1] = fc[1]; 
	return SLang_push_value (v->sltype, dc);
   }
   else {
	SLang_Array_Type *a;		/* mark array as read-only b/c  */
	unsigned int n;			/* mapping back to single prec  */
	double *dc;			/* isn't done on element assign */

	a = SLang_create_array(v->sltype, 1, NULL, v->dims, v->rank);
	if (a == NULL) return -1;

	dc = (double *)a->data;
	n = a->num_elements;
	while(n--) { *dc++ = *fc++; *dc++ = *fc++; }

	return SLang_push_array(a, 1);
   }
}  /* }}} */

static int pop_scomplex(CommBlockVar *v)  /* {{{ */
{
   double dc[2];
   float *fc = (float *)v->data;

   if (SLang_pop_value (v->sltype, dc) != 0)
	return -1;

   fc[0] = dc[0];
   fc[1] = dc[1];

   return 0;
}  /* }}} */

static int push_generic(CommBlockVar *v) /*{{{*/
{
   SLang_Array_Type *a;

   if (v->rank == 0)
	return SLang_push_value (v->sltype, v->data);

   if (NULL == (a = SLang_create_array(v->sltype,0,v->data,v->dims,v->rank)))
	return -1;

   a->free_fun = array_destroy_no_op;	/* prevent freeing of data */
   return SLang_push_array(a, 1);
} /*}}}*/

static int pop_generic(CommBlockVar *v)  /* {{{ */
{
    return SLang_pop_value (v->sltype, v->data);
}  /* }}} */

static int get_var(CommBlock *block, char *name, CommBlockVar **var) /*{{{*/
{
   if ( NULL == (*var = (CommBlockVar *)findcomm(name, block->vars, sizeof(CommBlockVar)))) {
	SLang_verror(SL_USAGE_ERROR,
		"Common block %s does not contain variable named: %s", 
							block->name, name);
	return -1;
   }

   return 0;
} /*}}}*/

static int block_sget(SLtype type, char* varname)  /* {{{ */
{
   CommBlock *block;
   CommBlockVar *var;

   (void) type;

   if (pop_common_block(&block) != 0 || get_var(block, varname, &var) != 0)
	return -1;

   return var->push(var);
}  /* }}} */

static int block_sput(SLtype type, char* varname)  /* {{{ */
{
   CommBlock *block;
   CommBlockVar *var;

   (void) type; 

   if (pop_common_block(&block) != 0 || get_var(block, varname, &var) != 0)
	return -1;

   if (var->rank == 0 || (var->sltype == SLANG_STRING_TYPE && var->rank == 1))
	return var->pop(var);

   (void) SLdo_pop();
   SLang_verror(SL_NOT_IMPLEMENTED,"CommBlock array assign not implemented.");
   return -1;

}  /* }}} */

static char* block_string(SLtype type, void* block_mmt_ptr)  /* {{{ */
{
   char buf[256];
   char *str;
   CommBlock *b;
   CommBlockVar *v;
   unsigned int strsize = 4 * sizeof(buf);

   b = (CommBlock *)SLang_object_from_mmt( *(SLang_MMT_Type**)block_mmt_ptr );

   if (NULL == (str = SLmalloc(strsize)))
	return SLmake_string("block_string: malloc failure");

   sprintf(str, "Fortran common block with %d variable", b->num_vars);
   if (b->num_vars > 1)
	strcat(str, "s:");
   else
	strcat(str, ":");

   v = b->vars;

   while (v->name != NULL) {

	int rank = v->rank;
	SLindex_Type *dims = v->dims;

	type = v->sltype;
	if (type == SLANG_STRING_TYPE) {
	   rank--;
	   dims++;
	}

	sprintf(buf, "\n\t%s %s", v->name, SLclass_get_datatype_name(type));

	if (rank) {

	   int i = 0;
	   char dimbuf[64];

	   strcat(buf, "[");

	   while (1) {
		sprintf(dimbuf, "%d", dims[i++] );
		strcat(buf, dimbuf);
		if (i < rank)
		   strcat(buf, ",");
	        else
		   break;
	   }

	   strcat(buf, "]");
	}

	strcat(str, buf);

	if (type == SLANG_STRING_TYPE) {
	   sprintf(buf, " (length %d)", v->dims[0]);
	   strcat(str, buf);
	}

	if (strsize - strlen(str) < sizeof(buf)) {
	   strsize *= 2;
	   if (NULL == (str = SLrealloc(str, strsize)))
	      return SLmake_string("block_string: realloc failure");
	}

	v++;
    }
    return str;
}  /* }}} */

static void get_commblock(void) /*{{{*/
{
   CommBlock *block;
   SLang_MMT_Type *mmt;

   if (SLang_Num_Function_Args != 1 || pop_common_block(&block) != 0) 
	USAGE("CommBlock = get_commblock(common_block_name)");

   if ( NULL == (mmt = SLang_create_mmt(CommBlock_Type, block)))
	return;
	         
  SLang_push_mmt(mmt);
} /*}}}*/

static void get_commblock_value(void) /*{{{*/
{
   char *varname;

   if (SLang_Num_Function_Args != 2 || SLang_pop_slstring(&varname) != 0)
	USAGE("value = get_commblock_value(CommBlock_or_name, var_name)");

   (void) block_sget(0, varname);

   SLang_free_slstring(varname);
} /*}}}*/

static void get_commblock_list(void)  /* {{{ */
{
   char **data;
   SLang_Array_Type *a;
   SLindex_Type i, n;
   
   if (SLang_Num_Function_Args != 0)
	USAGE("String_Type[] = get_commblock_list()");

   n = Num_CommBlocks;

   if (NULL == (a = SLang_create_array(SLANG_STRING_TYPE, 0, NULL, &n, 1)))
	return;

   data = (char **)a->data;

   for (i=0; i<n; i++)
	if (NULL == (data[i] = SLang_create_slstring(CommBlocks[i].name))) {
	   while(i--)
		SLang_free_slstring(data[i]);
	   SLang_free_array(a);
	   return;
	}

   SLang_push_array(a, 1);
}  /* }}} */

static void set_commblock_value(void) /*{{{*/
{
   char *varname;
   SLang_Any_Type *value;

   if (SLang_Num_Function_Args != 3
   			|| SLang_pop_anytype(&value) != 0
			|| SLang_pop_slstring(&varname) != 0
			|| SLang_push_anytype(value) != 0
			|| SLreverse_stack(2) != 0)
	USAGE("set_commblock_value(CommBlock_or_name, var_name, value)");

   (void) block_sput(0, varname);

   SLang_free_slstring(varname);
} /*}}}*/

static SLang_Intrin_Fun_Type CommBlock_Funcs[] = /*{{{*/
{
   MAKE_INTRINSIC_0("get_commblock_list", get_commblock_list, SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0("get_commblock", get_commblock, SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0("get_commblock_value", get_commblock_value, SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0("set_commblock_value", set_commblock_value, SLANG_VOID_TYPE),
   SLANG_END_INTRIN_FUN_TABLE
}; /*}}}*/

static void initblock(int *block_index, int *count, ...) /*{{{*/
{
   va_list ap;
   CommBlock *block = CommBlocks + *block_index;
   CommBlockVar *vars = block->vars;
   int i = *count;

   va_start(ap, *count);

   while(i--) {
	vars->data = va_arg(ap, void*);
	vars++;
   }
   va_end(ap);
} /*}}}*/

static int init_common_blocks(SLang_NameSpace_Type *ns) /*{{{*/
{
   CommBlock *block = CommBlocks;
   SLang_Class_Type *cl;

   /* FIXME: to use >1 common-block module each needs its own namespace */
   if (SLang_is_defined((char*)"_CommBlock_initialized")) {

	if (SLang_load_string("CommBlock") != 0 ||
				SLang_pop_datatype(&CommBlock_Type) != 0)
	   return -1;
   }
   else {

   	if (0 != SLang_load_string((char*)
			"public variable _CommBlock_initialized=1")
	    || NULL == (cl = SLclass_allocate_class ("CommBlock"))
	    || 0 != SLclass_set_destroy_function (cl, block_destroy_no_op)
	    || 0 != SLclass_set_sget_function (cl, block_sget)
	    || 0 != SLclass_set_sput_function (cl, block_sput)
	    || 0 != SLclass_set_string_function (cl, block_string)
	    || 0 != SLclass_register_class (cl, SLANG_VOID_TYPE,
				sizeof(CommBlock), SLANG_CLASS_TYPE_MMT))
	   return -1;

	CommBlock_Type = SLclass_get_class_id(cl);
    }

   if (0 != SLns_add_intrin_fun_table (ns, CommBlock_Funcs, "__CommBlocks__"))
	return -1;

   while(block->name != NULL) {
	block->init_func (initblock);
	block++;
   }

   if (isatty(fileno(stdout)))
	SLang_vmessage(
   	"This module interfaces to %d Fortran common blocks.\n"
   	"You may need to invoke the Fortran routine(s) which\n"
   	"define(s) them prior to using their values in S-Lang.\n"
	"You may use struct.field notation to access or modify\n"
	"the values of individual common block variables.\n"
	"Type \"help commblock\" for more information.\n", Num_CommBlocks);

   return 0;
} /*}}}*/
/* }}} */

static unsigned char map_scalars_to_refs = 2;

typedef struct _Slirp_Ref {			/* Ref handling code {{{ */
#define	REF_FLAG_FREE_DATA			0x01
#define	REF_FLAG_IS_OPAQUE			0x02
#define	REF_FLAG_COLUMN_MAJOR			0x04
#define	REF_FLAG_ARRAY_EXPECTED			0x08
   unsigned int		flags;		/* Slirp_Ref encapsulates S-Lang    */
   SLtype		sltype;		/* array, ref, and MMT types, the   */
   size_t		sizeof_type;	/* latter two of which are seen as  */
   void			**data;		/* pointing to a single object      */
   unsigned int		vstride;	/* how to find "next" vectored elem */
   SLang_Array_Type	*array;
   SLang_Ref_Type	*ref;
   SLang_MMT_Type	*mmt;		/* mmt supports passing around C    */
} Slirp_Ref;				/* ptr arrays of indeterminate size */

static Slirp_Ref* ref_new(SLtype t,size_t typesize, void *d,unsigned int flags)
{
   Slirp_Ref *ref;
   if ((ref = (Slirp_Ref*)SLcalloc( sizeof(Slirp_Ref), 1)) != NULL) {
	ref->sltype = t;
	ref->sizeof_type = typesize;
	ref->flags = flags;
	ref->data = (void**)d;
	*ref->data = NULL;
   }
   return ref;
}

static int ref_finalize(Slirp_Ref *r) /* {{{ */
{
   int status = 0;
   if (r == NULL) return 0;

   if (r->ref) {

        void *ref_value = NULL; SLtype ref_type = 0; double dc[2];

	if (r->flags & REF_FLAG_IS_OPAQUE) { 	/* wrap aggregates/opaques  */
#ifdef NUM_RESERVED_OPAQUES			/* in mmt before ref assign */
	   void *opaqval = *r->data;		/* the mmt w/be freed when  */
	   if (opaqval == NULL) {		/* the S-Lang object goes   */
		ref_value = NULL;		/* out of scope		    */
		ref_type = SLANG_NULL_TYPE;
	   }
	   else {
		SLang_MMT_Type *mmt = create_opaque_mmt(r->sltype, opaqval, 0);
		ref_value = &mmt;
		ref_type = r->sltype;
	   }
#endif
	}
	else {
	   ref_type = r->sltype;
	   if (ref_type == SLANG_COMPLEX_TYPE && r->sizeof_type < sizeof(dc)) {
		float *fc = (float*) r->data;
		dc[0] = fc[0];
		dc[1] = fc[1];
		ref_value = dc;
	   }
	   else
		ref_value = r->data;
	}

	status = SLang_assign_to_ref (r->ref, ref_type, ref_value);
	SLang_free_ref(r->ref);
   }
   else if (r->array) {
#ifdef HAVE_FORTRAN_CODE
	if ((r->flags & REF_FLAG_COLUMN_MAJOR) && TRANSPOSE(1,r->array) == -1)
		return -1;
#endif
	SLang_free_array(r->array);
   }
   else if (r->mmt)
	SLang_free_mmt(r->mmt);

   if (r->flags & REF_FLAG_FREE_DATA)
	SLfree( (char*) r->data );

   SLfree((char*)r);
   return status;
} /* }}} */

static void finalize_refs(unsigned int nargs, ...) /* {{{ */
{
   va_list ap;
   va_start(ap, nargs);
   while (nargs--) ref_finalize(va_arg(ap, Slirp_Ref *));
   va_end(ap);
} /* }}} */

static unsigned int ref_get_size(Slirp_Ref *r, int which_dimension) /* {{{ */
{
   if (r->array) {
	if (which_dimension == 0)
	   return (unsigned int)r->array->num_elements;
	else if (which_dimension < 0)
	   return r->array->num_dims;
	else {
	   which_dimension--;
	   if ((unsigned int)which_dimension < r->array->num_dims)
		return (unsigned int)r->array->dims[which_dimension];
	   else
		return 0;
	}
   }

   return 1;
} /* }}} */

extern LINKAGE int _SLang_get_class_type (SLtype t);	/* quasi-public  */

#ifdef NUM_RESERVED_OPAQUES
static SLtype sltype_to_opaque_ptr_type(SLtype sltype) /*{{{*/
{
   Reserved_Opaque_Type *pt;

   if (sltype > Last_Reserved_Opaque_Type) return opaque_ptr_Type;
   if (sltype == void_ptr_Type) return void_ptr_Type;

   pt = Reserved_Opaque_Types;		/* sequential search, but s/b < O(n) */
   while (pt->name) {			/* since list is ordered by expected */
	if (pt->masked_type == sltype)	/* frequency of use for each SLtype  */
	   return *pt->type;		
	pt++;
   }
   return 0;
} /*}}}*/
#endif

static int try_pop_mmt(SLtype type, SLang_MMT_Type **mmt) /*{{{*/
{
   static SLang_Name_Type *cl_type_func;	/* SLang_pop_mmt doesn't */
   int classtype;				/* validate that type is */
						/* an MMT, so we do here */
   *mmt = NULL;					/* FIXME: remove v2.0.7  */

   if (cl_type_func == NULL)
	cl_type_func = SLang_get_function( (char*) "__class_type");

   if (cl_type_func == NULL)
      return 0;

   if (-1 == SLang_push_datatype(type) ||		/* do the hard way, */
	-1 == SLexecute_function(cl_type_func) ||	/* as C api lacks   */
	-1 == SLang_pop_int(&classtype))		/* get_class_type() */
	return -1;

   if (classtype == SLANG_CLASS_TYPE_MMT) {
	*mmt = SLang_pop_mmt(type);
	return 1;
   }
   return 0;
} /*}}}*/

#define POP_FLAG_NULLABLE	0x1
#define POP_FLAG_VECTORIZE	0x2
static int pop_array_or_ref(Slirp_Ref *r, int flags, int defaultable) /*{{{*/
{
   SLtype type;
   unsigned int i, objtype;
#ifdef NUM_RESERVED_OPAQUES
   unsigned int is_opaque;
#endif

   if (r == NULL) {
	SLang_verror(SL_INTRINSIC_ERROR, (char*)"Attempted NULL reference (out of memory?)");
	return -1;
   }

   if (defaultable && SLang_Num_Function_Args < defaultable) {
	r->ref   = NULL;	/* observe that only NULL can be */
	*r->data = NULL;	/* assigned as the default value */
	return 0;
   }
   
   objtype = SLang_peek_at_stack();

   if ((flags & POP_FLAG_NULLABLE) && objtype == SLANG_NULL_TYPE) {
	r->ref   = NULL;		/* nullable flag: a pointer arg for */
	*r->data = NULL;		/* which NULL is a legitimate value */
	return SLang_pop_null ();
   }

   type = r->sltype;

#ifdef NUM_RESERVED_OPAQUES
   is_opaque =(type >= First_Opaque_Type && sltype_to_slirp_type(type) != NULL);
   if (is_opaque) r->flags |= REF_FLAG_IS_OPAQUE;
#endif

   switch(objtype) {

	case SLANG_ARRAY_TYPE:

	   if (SLang_pop_array_of_type(&r->array, type) == -1)
		return -1;

#ifdef HAVE_FORTRAN_CODE
	   if (r->flags & REF_FLAG_COLUMN_MAJOR) {
		if (flags & POP_FLAG_VECTORIZE)		/* vectorizable arrs*/
		   r->flags ^= REF_FLAG_COLUMN_MAJOR;   /* r not transposed */
		else if (TRANSPOSE(0,r->array) == -1)
		   return -1;
	   }
#endif

	   i = r->array->num_elements;
#ifdef NUM_RESERVED_OPAQUES
	   if (is_opaque) {
	      	Slirp_Opaque *ot;
		SLang_MMT_Type** mmts = (SLang_MMT_Type**)r->array->data;
		void **arr = (void**)SLmalloc(i * sizeof(void*) );
		if (arr == NULL) return -1;

		while (i--) {
		   ot = (Slirp_Opaque*) SLang_object_from_mmt (mmts[i]);
		   if (ot == NULL) {
			SLfree((char*)arr);
			return -1;
		   }
		   arr[i] = ot->instance;
		}

		*r->data = (void*)arr; r->data = (void**)arr;
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else
#endif
	   if (type == SLANG_COMPLEX_TYPE &&
		 		r->sizeof_type < r->array->sizeof_type) {
		double *dc = (double*) r->array->data;
		float  *fc = (float *) SLmalloc(i * r->sizeof_type);
		if (fc == NULL) return -1;
		*r->data = fc; r->data = (void**)fc;
		while (i--) { *fc++ = (float) *dc++; *fc++ = (float) *dc++; }
		r->flags |= REF_FLAG_FREE_DATA;
	   }
	   else {
		*r->data = r->array->data;
		r->data = (void**)*r->data;
	   }

	   break;

	case SLANG_REF_TYPE:

	   /* Refs can only send values one-way (C to S-Lang, not reverse) */
	   if (SLang_pop_ref(&r->ref) == -1)
		return -1;

	   /* Ref is assumed to point to a scalar instance of the  */
	   /* refd type, so declare enough space to hold one such. */
	   *r->data = (void*)SLmalloc(r->sizeof_type);
	   if (*r->data == NULL) return -1;
	   memset(*r->data, 0, r->sizeof_type);
	   r->flags |= REF_FLAG_FREE_DATA;
	   r->data = (void**)*r->data;
	   break;

	/* Allow scalars to used as if they were 1-element arrays */
	case SLANG_CHAR_TYPE: case SLANG_UCHAR_TYPE:
	case SLANG_SHORT_TYPE: case SLANG_USHORT_TYPE:
	case SLANG_INT_TYPE: case SLANG_UINT_TYPE:
	case SLANG_LONG_TYPE: case SLANG_ULONG_TYPE:
	case SLANG_FLOAT_TYPE: case SLANG_DOUBLE_TYPE:
	case SLANG_COMPLEX_TYPE: case SLANG_STRING_TYPE:

	   /* Accomodate FORTRAN-style pass by reference semantics */
	   if (map_scalars_to_refs &&
		 	SLang_pop_array_of_type(&r->array,type) == 0) {

		*r->data = (void*)SLmalloc(r->sizeof_type);
		if (*r->data == NULL) return -1;

		if (r->sizeof_type == r->array->sizeof_type)
		   memcpy(*r->data, r->array->data, r->sizeof_type);
		else if (type == SLANG_COMPLEX_TYPE) {
		   double *dc = (double*) r->array->data;
		   float  *fc = (float*) *r->data;
		   fc[0] = (float)dc[0];
		   fc[1] = (float)dc[1];
		}
		else  {
		   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"mismatched type sizes, when popping scalar as ref");
		   SLang_free_array(r->array);
		   return -1;
		}

		r->data = (void**)*r->data;
		r->flags |= REF_FLAG_FREE_DATA;
		/* Nullify to distinguish between vectored/non-vectored args */
		SLang_free_array(r->array); r->array = NULL;
		break;
	   }				/* intentional fallthrough */

	default:

#ifdef NUM_RESERVED_OPAQUES
	   if (objtype >= First_Opaque_Type && 
		 		sltype_to_slirp_type(objtype) != NULL) {

		if (!(flags & POP_FLAG_VECTORIZE))
		   type = sltype_to_opaque_ptr_type(type);

		if (type) {

		   Slirp_Opaque *otp;
		   if (SLang_pop_opaque(type, NULL, &otp) == -1)
			return -1;
		
		   if (flags & POP_FLAG_VECTORIZE) {
			void **arr = (void**) SLmalloc(sizeof(void*));
			if (arr == NULL) return -1;
			arr[0] = otp->instance;
			*r->data = arr;
			r->flags |= REF_FLAG_FREE_DATA;
		   }
		   else
			*r->data = otp->instance;

		   r->data = (void**)*r->data;
		   r->mmt = otp->mmt;
		   return 0;
		}
	   }
	   else
#endif
	   if ( try_pop_mmt(objtype, &r->mmt) == 1 &&
		(*r->data = SLang_object_from_mmt (r->mmt)) != NULL) {
		   r->data = (void**)*r->data;	 /* not flagged for freeing */
		   return 0;
	   }

	   SLang_verror(SL_TYPE_MISMATCH, (char*)
			"context requires array, ref, or opaque pointer");
	   return -1;
   }
   return 0;
} /*}}}*/
/* }}} */

/* Wrapper functions */ /* {{{ */
extern LINKAGE void k1sfwrap_ (double*,double*);
static void sl_k1 (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   k1sfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (0, 0, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void getlun_ (int*);
static void sl_getlun (void)
{
   int* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg1,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   getlun_(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (1, 1, 0);
   finalize_refs(1,arg1_r); 
}

extern LINKAGE void interspline_ (int*,double*,double*,double*,double*,double*,double*,double*);
static void sl_interspline (void)
{
   int* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   double* arg7;
   Slirp_Ref *arg7_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg7,0x0);
   double* arg8;
   Slirp_Ref *arg8_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg8,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 7 || SLang_Num_Function_Args > 8) goto usage_label;
   if (-1 == pop_array_or_ref( arg8_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg7_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 1)) goto usage_label;
   issue_usage = 0;

   if (arg1 == NULL)
	arg1 = arg2_r->array->dims;
   interspline_(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (2, 2, 0);
   finalize_refs(8,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r,arg7_r,arg8_r); 
}

extern LINKAGE void xrbjet_ (double*,int*,double*,int*,double*,double*);
static void sl_xrbjet (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   int* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   int* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 5 || SLang_Num_Function_Args > 6) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 2)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   if (arg2 == NULL)
	arg2 = arg1_r->array->dims;
   xrbjet_(arg1, arg2, arg3, arg4, arg5, arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (3, 3, 0);
   finalize_refs(6,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r); 
}

extern LINKAGE void k0sfwrap_ (double*,double*);
static void sl_k0 (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   k0sfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (4, 4, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void qrombe_dbl2_ (double*,double*,double*,double*,double*);
static void sl_qrombe_dbl2 (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   qrombe_dbl2_(arg1, arg2, arg3, arg4, arg5);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (5, 5, 0);
   finalize_refs(5,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r); 
}

extern LINKAGE void jetpars_ (double*,double*,double*,double*,double*,double*,double*,double*,double*,double*,double*);
static void sl_jetpars (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   double* arg7;
   Slirp_Ref *arg7_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg7,0x0);
   double* arg8;
   Slirp_Ref *arg8_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg8,0x0);
   double* arg9;
   Slirp_Ref *arg9_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg9,0x0);
   double* arg10;
   Slirp_Ref *arg10_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg10,0x0);
   double* arg11;
   Slirp_Ref *arg11_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg11,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 11) goto usage_label;
   if (-1 == pop_array_or_ref( arg11_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg10_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg9_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg8_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg7_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   jetpars_(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (6, 6, 0);
   finalize_refs(11,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r,arg7_r,arg8_r,arg9_r,arg10_r,arg11_r); 
}

extern LINKAGE void absfncsfwrap_ (double*,double*);
static void sl_absfnc (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   absfncsfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (7, 7, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void comintsfwrap_ (double*,double*);
static void sl_comint (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   comintsfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (8, 8, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void frelun_ (int*);
static void sl_frelun (void)
{
   int* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg1,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   frelun_(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (9, 9, 0);
   finalize_refs(1,arg1_r); 
}

extern LINKAGE void k2sfwrap_ (double*,double*);
static void sl_k2 (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   k2sfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (10, 10, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void polint_dbl2_ (double*,double*,int*,double*,double*,double*);
static void sl_polint_dbl2 (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 5 || SLang_Num_Function_Args > 6) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 3)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   if (arg3 == NULL)
	arg3 = arg1_r->array->dims;
   polint_dbl2_(arg1, arg2, arg3, arg4, arg5, arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (11, 11, 0);
   finalize_refs(6,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r); 
}

extern LINKAGE void trapzd_dbl2_ (double*,double*,double*,double*,int*);
static void sl_trapzd_dbl2 (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   int* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg5,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   trapzd_dbl2_(arg1, arg2, arg3, arg4, arg5);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (12, 12, 0);
   finalize_refs(5,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r); 
}

extern LINKAGE void lunlst_ (int*);
static void sl_lunlst (void)
{
   int* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg1,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   lunlst_(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (13, 13, 0);
   finalize_refs(1,arg1_r); 
}

extern LINKAGE void synint_ (double*,double*,double*,double*,double*,double*,double*,double*,double*);
static void sl_synint (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   double* arg7;
   Slirp_Ref *arg7_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg7,0x0);
   double* arg8;
   Slirp_Ref *arg8_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg8,0x0);
   double* arg9;
   Slirp_Ref *arg9_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg9,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 9) goto usage_label;
   if (-1 == pop_array_or_ref( arg9_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg8_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg7_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   synint_(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (14, 14, 0);
   finalize_refs(9,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r,arg7_r,arg8_r,arg9_r); 
}

extern LINKAGE void initspline_ (int*,double*,double*,double*,double*,double*);
static void sl_initspline (void)
{
   int* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 5 || SLang_Num_Function_Args > 6) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 1)) goto usage_label;
   issue_usage = 0;

   if (arg1 == NULL)
	arg1 = arg2_r->array->dims;
   initspline_(arg1, arg2, arg3, arg4, arg5, arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (15, 15, 0);
   finalize_refs(6,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r); 
}

extern LINKAGE void polint_dbl_ (double*,double*,int*,double*,double*,double*);
static void sl_polint_dbl (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   double* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg6,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 5 || SLang_Num_Function_Args > 6) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 3)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   if (arg3 == NULL)
	arg3 = arg1_r->array->dims;
   polint_dbl_(arg1, arg2, arg3, arg4, arg5, arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (16, 16, 0);
   finalize_refs(6,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r); 
}

extern LINKAGE void qrombe_dbl_ (double*,double*,double*,double*,double*);
static void sl_qrombe_dbl (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   double* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg5,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   qrombe_dbl_(arg1, arg2, arg3, arg4, arg5);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (17, 17, 0);
   finalize_refs(5,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r); 
}

extern LINKAGE void k3sfwrap_ (double*,double*);
static void sl_k3 (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   k3sfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (18, 18, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void trapzd_dbl_ (double*,double*,double*,double*,int*);
static void sl_trapzd_dbl (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   double* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg4,0x0);
   int* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg5,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 5) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   trapzd_dbl_(arg1, arg2, arg3, arg4, arg5);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (19, 19, 0);
   finalize_refs(5,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r); 
}

extern LINKAGE void initjet_ (void);
static void sl_initjet (void)
{
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 0) goto usage_label;
   issue_usage = 0;

   initjet_();
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (20, 20, 0);
}

extern LINKAGE void comfncsfwrap_ (double*,double*);
static void sl_comfnc (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   comfncsfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (21, 21, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void xrbinterp_ (double*,double*,double*,float*,int*,int*);
static void sl_xrbinterp (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   float* arg4;
   Slirp_Ref *arg4_r = ref_new(SLANG_FLOAT_TYPE,sizeof(float),&arg4,0x0);
   int* arg5;
   Slirp_Ref *arg5_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg5,0x0);
   int* arg6;
   Slirp_Ref *arg6_r = ref_new(SLANG_INT_TYPE,sizeof(int),&arg6,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args < 4 || SLang_Num_Function_Args > 6) goto usage_label;
   if (-1 == pop_array_or_ref( arg6_r, 0x0, 6)) goto usage_label;
   if (-1 == pop_array_or_ref( arg5_r, 0x0, 5)) goto usage_label;
   if (-1 == pop_array_or_ref( arg4_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   if (arg6 == NULL)
	arg6 = arg4_r->array->dims;
   if (arg5 == NULL)
	arg5 = arg1_r->array->dims;
   xrbinterp_(arg1, arg2, arg3, arg4, arg5, arg6);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (22, 22, 0);
   finalize_refs(6,arg1_r,arg2_r,arg3_r,arg4_r,arg5_r,arg6_r); 
}

extern LINKAGE void synemissfwrap_ (double*,double*);
static void sl_synemis (void)
{
   double arg1;
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 1) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   synemissfwrap_(&arg1, arg2);
   (void)SLang_push_double(arg1);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (23, 23, 0);
   finalize_refs(1,arg2_r); 
}

extern LINKAGE void synintegrals_ (double*,double*,double*);
static void sl_synintegrals (void)
{
   double* arg1;
   Slirp_Ref *arg1_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg1,0x0);
   double* arg2;
   Slirp_Ref *arg2_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg2,0x0);
   double* arg3;
   Slirp_Ref *arg3_r = ref_new(SLANG_DOUBLE_TYPE,sizeof(double),&arg3,0x0);
   int issue_usage = 1;

   if (SLang_Num_Function_Args != 3) goto usage_label;
   if (-1 == pop_array_or_ref( arg3_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg2_r, 0x0, 0)) goto usage_label;
   if (-1 == pop_array_or_ref( arg1_r, 0x0, 0)) goto usage_label;
   issue_usage = 0;

   synintegrals_(arg1, arg2, arg3);
   goto free_and_return;
free_and_return:
   /* drop */
usage_label:
   if (issue_usage) Slirp_usage (24, 24, 0);
   finalize_refs(3,arg1_r,arg2_r,arg3_r); 
}


static SLang_Intrin_Fun_Type simplejet_Funcs [] =
{
   MAKE_INTRINSIC_0((char*)"k1",sl_k1,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"getlun",sl_getlun,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"interspline",sl_interspline,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"xrbjet",sl_xrbjet,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k0",sl_k0,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"qrombe_dbl2",sl_qrombe_dbl2,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"jetpars",sl_jetpars,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"absfnc",sl_absfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"comint",sl_comint,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"frelun",sl_frelun,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k2",sl_k2,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"polint_dbl2",sl_polint_dbl2,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"trapzd_dbl2",sl_trapzd_dbl2,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"lunlst",sl_lunlst,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synint",sl_synint,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"initspline",sl_initspline,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"polint_dbl",sl_polint_dbl,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"qrombe_dbl",sl_qrombe_dbl,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"k3",sl_k3,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"trapzd_dbl",sl_trapzd_dbl,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"initjet",sl_initjet,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"comfnc",sl_comfnc,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"xrbinterp",sl_xrbinterp,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synemis",sl_synemis,SLANG_VOID_TYPE),
   MAKE_INTRINSIC_0((char*)"synintegrals",sl_synintegrals,SLANG_VOID_TYPE),
   SLANG_END_INTRIN_FUN_TABLE
};   /* }}} */

static const char* usage_strings[] = { /* {{{ */
   "double = k1(double)",
   "getlun(int)",
   "interspline(int,double[n],double[n],double[n],double[n],double[n],double [,int])",
   "xrbjet(double[ne- 47],int=ne,double[15],int,double[ne] [,int=ne])",
   "double = k0(double)",
   "qrombe_dbl2(double,double,double,double,double)",
   "jetpars(double,double,double,double,double,double,double,double,double,double,double)",
   "double = absfnc(double)",
   "double = comint(double)",
   "frelun(int)",
   "double = k2(double)",
   "polint_dbl2(double[n],double[n],int=n,double,double [,int=n])",
   "trapzd_dbl2(double,double,double,double,int)",
   "lunlst(int)",
   "synint(double,double,double,double,double,double,double,double,double)",
   "initspline(int,double[n],double[n],double[n],double[n] [,int])",
   "polint_dbl(double[n],double[n],int=n,double,double [,int=n])",
   "qrombe_dbl(double,double,double,double,double)",
   "double = k3(double)",
   "trapzd_dbl(double,double,double,double,int)",
   "initjet()",
   "double = comfnc(double)",
   "xrbinterp(double[ne],double[ne],double[ne],float[newne] [,int=ne,int=newne])",
   "double = synemis(double)",
   "synintegrals(double,double,double)",
NULL
}; /* }}} */

static void Slirp_usage(int i, int last, int flags) /* {{{ */
{
   char *indent;
   int npop = SLstack_depth();
   if (npop > SLang_Num_Function_Args) npop = SLang_Num_Function_Args;
   SLdo_pop_n(npop);
   if (last == i)
	indent = (char*)"Usage:  ";
   else {
	indent = (char*)"\t";
	SLang_verror(SL_USAGE_ERROR, (char*)"Usage: one of");
   }
   do
	SLang_verror(SL_USAGE_ERROR, (char*)"%s%s", indent, usage_strings[i++]);
   while (i < last);
   if (flags & 0x2)
	SLang_verror(SL_USAGE_ERROR,
		(char*)"\tThis function has been vectorized and parallelized.");
   else if (flags & 0x1)
	SLang_verror(SL_USAGE_ERROR, (char*)"\tThis function has been vectorized.");
} /* }}} */

#define SLIRP_VERSION_STRING pre2.0.0-34
#define SLIRP_VERSION_NUMBER 20000
SLANG_MODULE(simplejet);
int init_simplejet_module_ns(char *ns_name)	/* {{{ */
{
   SLang_NameSpace_Type *ns = NULL;

   if (slang_abi_mismatch()) return -1;
   if (ns_name != NULL) {
	ns = SLns_create_namespace (ns_name);
       if (ns == NULL ||
          (slns = SLmalloc(strlen(ns_name)+1)) == NULL)
          return -1;
       strcpy(slns, ns_name);
   }

   (void) &ref_get_size; /* avoid compile warn if unused */

#ifdef HAVE_OPAQUE_IVARS
   if (-1 == set_opaque_ivar_types(simplejet_Opaque_IVars) ||
       -1 == SLns_add_intrin_var_table(ns,simplejet_Opaque_IVars,NULL))
	return -1;
#endif

   if (	-1 == SLns_add_intrin_fun_table (ns,simplejet_Funcs,(char*)"__simplejet__"))
	return -1;

   if (init_common_blocks(ns) != 0)
	return -1;

   transposer = SLang_get_function( (char*)"transpose");

   return 0;
} /* }}} */
